// TDD Tests for Smart Policy Correlation Engine
// Milestone 2: Policy Generation & Validation Testing

import { SmartPolicyCorrelationEngine } from '../policy/smart-policy-correlation-engine';
import { RoleRegulationMatrix } from '../policy/role-regulation-matrix';

describe('SmartPolicyCorrelationEngine', () => {
  let engine: SmartPolicyCorrelationEngine;
  let roleMatrix: RoleRegulationMatrix;

  beforeEach(() => {
    roleMatrix = new RoleRegulationMatrix();
    engine = new SmartPolicyCorrelationEngine(roleMatrix);
  });

  describe('Initialization', () => {
    test('should initialize with role matrix', () => {
      expect(engine).toBeDefined();
      expect(roleMatrix).toBeDefined();
    });

    test('should have default confidence threshold', () => {
      // Access private property for testing
      const engineAny = engine as any;
      expect(engineAny.confidenceThreshold).toBe(0.85);
    });
  });

  describe('Policy Generation', () => {
    test('should generate policy recommendation for security engineer', async () => {
      const request = {
        roleTemplateId: 'security-engineer-l3',
        regulatoryFramework: 'GDPR' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      expect(recommendation?.roleTemplateId).toBe('security-engineer-l3');
      expect(recommendation?.regulatoryFramework).toBe('GDPR');
      expect(recommendation?.policyTitle).toContain('GDPR');
      expect(recommendation?.autoGenerated).toBe(true);
    });

    test('should generate policy recommendation for frontend developer', async () => {
      const request = {
        roleTemplateId: 'frontend-developer-l2',
        regulatoryFramework: 'EU_AI_ACT' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      expect(recommendation?.roleTemplateId).toBe('frontend-developer-l2');
      expect(recommendation?.regulatoryFramework).toBe('EU_AI_ACT');
      expect(recommendation?.policyTitle).toContain('EU_AI_ACT');
    });

    test('should return null for non-existent role', async () => {
      const request = {
        roleTemplateId: 'non-existent-role',
        regulatoryFramework: 'GDPR' as const
      };

      await expect(engine.generatePolicyRecommendation(request))
        .rejects.toThrow('Role profile not found for ID: non-existent-role');
    });

    test('should generate policy with custom confidence threshold', async () => {
      const request = {
        roleTemplateId: 'security-engineer-l3',
        regulatoryFramework: 'GDPR' as const,
        confidenceThreshold: 0.9
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      if (recommendation) {
        expect(recommendation.confidence).toBeGreaterThanOrEqual(0.9);
      }
    });
  });

  describe('Policy Content Generation', () => {
    test('should generate policy with required sections', async () => {
      const request = {
        roleTemplateId: 'security-engineer-l3',
        regulatoryFramework: 'GDPR' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      if (recommendation) {
        const content = recommendation.policyContent;
        expect(content).toContain('## Purpose');
        expect(content).toContain('## Scope');
        expect(content).toContain('## Requirements');
        expect(content).toContain('## Responsibilities');
        expect(content).toContain('## Compliance');
      }
    });

    test('should include role-specific content', async () => {
      const request = {
        roleTemplateId: 'frontend-developer-l2',
        regulatoryFramework: 'OWASP' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      if (recommendation) {
        const content = recommendation.policyContent;
        expect(content).toContain('L2 Frontend Developer');
        expect(content).toContain('Design');
      }
    });

    test('should include regulatory requirements', async () => {
      const request = {
        roleTemplateId: 'security-engineer-l3',
        regulatoryFramework: 'NIS2' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      if (recommendation) {
        const content = recommendation.policyContent;
        expect(content).toContain('incident_response');
        expect(content).toContain('vulnerability_management');
        expect(content).toContain('threat_intelligence');
      }
    });
  });

  describe('Policy Validation', () => {
    test('should validate policy structure correctly', async () => {
      const request = {
        roleTemplateId: 'security-engineer-l3',
        regulatoryFramework: 'GDPR' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      if (recommendation) {
        expect(recommendation.requiresReview).toBeDefined();
        expect(typeof recommendation.confidence).toBe('number');
        expect(recommendation.confidence).toBeGreaterThan(0);
        expect(recommendation.confidence).toBeLessThanOrEqual(1);
      }
    });

    test('should calculate confidence scores correctly', async () => {
      const request = {
        roleTemplateId: 'devops-architect-l4',
        regulatoryFramework: 'NIST_CSF' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      if (recommendation) {
        // DevOps architect has HIGH impact on NIST_CSF, so should have high confidence
        expect(recommendation.confidence).toBeGreaterThan(0.8);
      }
    });

    test('should mark policies for review when confidence is low', async () => {
      // This test would require mocking the validation to return low confidence
      // For now, test the basic structure
      const request = {
        roleTemplateId: 'frontend-developer-l2',
        regulatoryFramework: 'NIS2' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      if (recommendation) {
        expect(recommendation.requiresReview).toBeDefined();
        expect(typeof recommendation.requiresReview).toBe('boolean');
      }
    });
  });

  describe('Batch Policy Generation', () => {
    test('should generate policies for multiple roles', async () => {
      const roleIds = ['security-engineer-l3', 'frontend-developer-l2', 'devops-architect-l4'];

      const recommendations = await engine.generateBatchPolicyRecommendations(roleIds);

      expect(recommendations.length).toBeGreaterThan(0);
      expect(recommendations.length).toBeLessThanOrEqual(roleIds.length);

      // Should be sorted by confidence (highest first)
      for (let i = 1; i < recommendations.length; i++) {
        expect(recommendations[i - 1].confidence).toBeGreaterThanOrEqual(recommendations[i].confidence);
      }
    });

    test('should generate policies for specific framework', async () => {
      const roleIds = ['security-engineer-l3', 'frontend-developer-l2'];

      const recommendations = await engine.generateBatchPolicyRecommendations(roleIds, 'GDPR');

      expect(recommendations.length).toBeGreaterThan(0);
      recommendations.forEach(rec => {
        expect(rec.regulatoryFramework).toBe('GDPR');
      });
    });

    test('should handle errors gracefully in batch generation', async () => {
      const roleIds = ['security-engineer-l3', 'non-existent-role', 'frontend-developer-l2'];

      const recommendations = await engine.generateBatchPolicyRecommendations(roleIds);

      // Should still generate policies for valid roles
      expect(recommendations.length).toBeGreaterThan(0);
      expect(recommendations.length).toBeLessThan(roleIds.length);
    });
  });

  describe('Policy Statistics', () => {
    test('should return correct policy statistics', () => {
      const stats = engine.getPolicyStatistics();

      expect(stats.totalRoles).toBe(3); // security-engineer, frontend-developer, devops-architect
      expect(stats.totalRoles).toBeGreaterThan(0);
      expect(stats.averageConfidence).toBeGreaterThan(0);
      expect(stats.averageConfidence).toBeLessThanOrEqual(1);

      // Verify counts add up
      const totalCounted = stats.highConfidencePolicies +
        stats.mediumConfidencePolicies +
        stats.lowConfidencePolicies;
      expect(totalCounted).toBe(stats.totalRoles);
    });

    test('should categorize policies by confidence level', () => {
      const stats = engine.getPolicyStatistics();

      // Security engineer and DevOps architect should be high confidence
      expect(stats.highConfidencePolicies).toBeGreaterThanOrEqual(2);

      // Frontend developer should be medium confidence
      expect(stats.mediumConfidencePolicies).toBeGreaterThanOrEqual(1);

      expect(stats.lowConfidencePolicies).toBeGreaterThanOrEqual(0);
    });
  });

  describe('Regulatory Framework Targeting', () => {
    test('should focus on high-impact frameworks by default', async () => {
      const request = {
        roleTemplateId: 'security-engineer-l3'
        // No specific framework specified
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      if (recommendation) {
        // Security engineer has HIGH impact on all frameworks, so should get one
        expect(recommendation.regulatoryFramework).toBeDefined();
      }
    });

    test('should respect specific framework requests', async () => {
      const request = {
        roleTemplateId: 'frontend-developer-l2',
        regulatoryFramework: 'OWASP' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      if (recommendation) {
        expect(recommendation.regulatoryFramework).toBe('OWASP');
      }
    });
  });

  describe('Error Handling', () => {
    test('should handle missing role profiles gracefully', async () => {
      const request = {
        roleTemplateId: 'missing-role-id'
      };

      await expect(engine.generatePolicyRecommendation(request))
        .rejects.toThrow('Role profile not found for ID: missing-role-id');
    });

    test('should handle batch generation errors gracefully', async () => {
      const roleIds = ['security-engineer-l3', 'invalid-role', 'frontend-developer-l2'];

      // Should not throw, should continue processing valid roles
      const recommendations = await engine.generateBatchPolicyRecommendations(roleIds);

      expect(Array.isArray(recommendations)).toBe(true);
      expect(recommendations.length).toBeGreaterThan(0);
    });
  });

  describe('Integration with Role Matrix', () => {
    test('should use role matrix data correctly', async () => {
      const request = {
        roleTemplateId: 'security-engineer-l3',
        regulatoryFramework: 'GDPR' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      if (recommendation) {
        // Should include citations from the role matrix
        expect(recommendation.citations).toContain('GDPR Article 32 - Security of processing');

        // Should include regulatory context
        expect(recommendation.regulatoryContext.length).toBeGreaterThan(0);
      }
    });

    test('should reflect role matrix updates', async () => {
      // Update a role profile
      roleMatrix.updateRoleProfile('security-engineer-l3', {
        complianceScore: 0.98
      });

      const request = {
        roleTemplateId: 'security-engineer-l3',
        regulatoryFramework: 'GDPR' as const
      };

      const recommendation = await engine.generatePolicyRecommendation(request);

      expect(recommendation).toBeDefined();
      // The engine should still work with updated data
    });
  });
});
