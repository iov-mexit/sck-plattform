// Smart Policy Correlation Engine: Integrates RAG with role-specific regulatory requirements
// TDD Implementation: AI-powered policy generation with confidence scoring

import { RoleRegulationMatrix, RoleRegulatoryProfile, RegulatoryFramework } from './role-regulation-matrix';
import { RoleTemplate } from '../types/role-templates';

export interface PolicyRecommendation {
  roleTemplateId: string;
  roleTitle: string;
  regulatoryFramework: RegulatoryFramework;
  policyTitle: string;
  policyContent: string;
  confidence: number;
  regulatoryContext: string[];
  citations: string[];
  autoGenerated: boolean;
  requiresReview: boolean;
  createdAt: Date;
}

export interface PolicyGenerationRequest {
  roleTemplateId: string;
  regulatoryFramework?: RegulatoryFramework;
  specificRequirement?: string;
  confidenceThreshold?: number;
  includeCitations?: boolean;
}

export interface PolicyValidationResult {
  isValid: boolean;
  confidence: number;
  regulatoryCoverage: number;
  roleSpecificity: number;
  complianceScore: number;
  recommendations: string[];
  requiresReview: boolean;
}

// New interface for the unified system
export interface PolicyCorrelationRequest {
  roleTemplate: RoleTemplate;
  regulatoryFramework: RegulatoryFramework;
  policyContent: string;
  specificRequirement: string;
}

export interface PolicyCorrelationResult {
  regulatoryImpact: number;
  roleAlignment: number;
  complianceScore: number;
  recommendations: string[];
}

export class SmartPolicyCorrelationEngine {
  private roleMatrix: RoleRegulationMatrix;
  private confidenceThreshold: number = 0.85;

  constructor(roleMatrix?: RoleRegulationMatrix) {
    this.roleMatrix = roleMatrix || new RoleRegulationMatrix();
  }

  // New method for the unified system
  async correlatePolicy(request: PolicyCorrelationRequest): Promise<PolicyCorrelationResult> {
    try {
      // Analyze policy content for regulatory alignment
      const regulatoryImpact = this.analyzeRegulatoryImpact(request.policyContent, request.regulatoryFramework);
      const roleAlignment = this.analyzeRoleAlignment(request.policyContent, request.roleTemplate);
      const complianceScore = this.calculateComplianceScore(request.policyContent, request.regulatoryFramework);
      const recommendations = this.generateCorrelationRecommendations(request);

      return {
        regulatoryImpact,
        roleAlignment,
        complianceScore,
        recommendations
      };
    } catch (error) {
      console.error('Error in policy correlation:', error);
      return {
        regulatoryImpact: 0.5,
        roleAlignment: 0.5,
        complianceScore: 0.5,
        recommendations: ['Policy correlation analysis failed']
      };
    }
  }

  private analyzeRegulatoryImpact(policyContent: string, framework: RegulatoryFramework): number {
    const content = policyContent.toLowerCase();
    let score = 0.5; // Base score

    // Framework-specific scoring
    if (framework === 'OWASP') {
      if (content.includes('a01:2021') || content.includes('a02:2021') || content.includes('a03:2021')) score += 0.2;
      if (content.includes('owasp top 10') || content.includes('owasp guidelines')) score += 0.15;
      if (content.includes('injection') || content.includes('xss') || content.includes('csrf')) score += 0.1;
      if (content.includes('secure coding') || content.includes('vulnerability')) score += 0.05;
    }

    if (framework === 'GDPR') {
      if (content.includes('article 25') || content.includes('article 32')) score += 0.2;
      if (content.includes('data protection') || content.includes('privacy')) score += 0.15;
      if (content.includes('data subject') || content.includes('controller')) score += 0.1;
      if (content.includes('compliance') || content.includes('gdpr')) score += 0.05;
    }

    if (framework === 'NIS2') {
      if (content.includes('incident response') || content.includes('cybersecurity')) score += 0.2;
      if (content.includes('security operations') || content.includes('soc')) score += 0.15;
      if (content.includes('threat detection') || content.includes('monitoring')) score += 0.1;
      if (content.includes('nis2') || content.includes('compliance')) score += 0.05;
    }

    return Math.min(score, 1.0);
  }

  private analyzeRoleAlignment(policyContent: string, roleTemplate: RoleTemplate): number {
    const content = policyContent.toLowerCase();
    const roleTitle = roleTemplate.title.toLowerCase();
    const roleCategory = roleTemplate.category.toLowerCase();
    let score = 0.5; // Base score

    // Role title alignment
    if (content.includes(roleTitle)) score += 0.2;
    if (content.includes(roleCategory)) score += 0.15;

    // Role-specific content alignment
    if (roleTemplate.responsibilities.some(resp => content.includes(resp.toLowerCase()))) score += 0.1;
    if (roleTemplate.securityContributions.some(sec => content.includes(sec.title.toLowerCase()))) score += 0.05;

    return Math.min(score, 1.0);
  }

  private calculateComplianceScore(policyContent: string, framework: RegulatoryFramework): number {
    const content = policyContent.toLowerCase();
    let score = 0.5; // Base score

    // Compliance indicators
    if (content.includes('compliance') || content.includes('comply')) score += 0.1;
    if (content.includes('requirements') || content.includes('standards')) score += 0.1;
    if (content.includes('implementation') || content.includes('guidelines')) score += 0.1;
    if (content.includes('monitoring') || content.includes('assessment')) score += 0.1;
    if (content.includes('training') || content.includes('awareness')) score += 0.1;

    return Math.min(score, 1.0);
  }

  private generateCorrelationRecommendations(request: PolicyCorrelationRequest): string[] {
    const recommendations: string[] = [];
    const content = request.policyContent.toLowerCase();

    // Framework-specific recommendations
    if (request.regulatoryFramework === 'OWASP') {
      if (!content.includes('a01:2021') && !content.includes('a02:2021')) {
        recommendations.push('Consider adding specific OWASP Top 10 references (A01:2021, A02:2021)');
      }
      if (!content.includes('owasp top 10')) {
        recommendations.push('Include OWASP Top 10 framework reference');
      }
    }

    if (request.regulatoryFramework === 'GDPR') {
      if (!content.includes('article 25') && !content.includes('article 32')) {
        recommendations.push('Consider adding specific GDPR article references');
      }
      if (!content.includes('data protection')) {
        recommendations.push('Include data protection principles');
      }
    }

    if (request.regulatoryFramework === 'NIS2') {
      if (!content.includes('incident response')) {
        recommendations.push('Include incident response procedures');
      }
      if (!content.includes('cybersecurity')) {
        recommendations.push('Add cybersecurity measures');
      }
    }

    // General recommendations
    if (!content.includes('implementation')) {
      recommendations.push('Add implementation guidelines');
    }
    if (!content.includes('compliance')) {
      recommendations.push('Include compliance monitoring procedures');
    }

    return recommendations.length > 0 ? recommendations : ['Policy correlation analysis complete'];
  }

  // Core policy generation method
  async generatePolicyRecommendation(
    request: PolicyGenerationRequest
  ): Promise<PolicyRecommendation | null> {

    // 1. Get role profile and regulatory context
    const roleProfile = this.roleMatrix.getRoleProfile(request.roleTemplateId);
    if (!roleProfile) {
      throw new Error(`Role profile not found for ID: ${request.roleTemplateId}`);
    }

    // 2. Determine regulatory frameworks to focus on
    const targetFrameworks = this.determineTargetFrameworks(roleProfile, request.regulatoryFramework);

    // 3. Generate policy content for each framework
    const policyRecommendations: PolicyRecommendation[] = [];

    for (const framework of targetFrameworks) {
      const requirement = roleProfile.regulatoryImpact[framework];
      if (requirement.impact === 'HIGH' || request.regulatoryFramework === framework) {
        const policy = await this.generateFrameworkSpecificPolicy(
          roleProfile,
          framework,
          requirement,
          request
        );
        if (policy) {
          policyRecommendations.push(policy);
        }
      }
    }

    // 4. Return highest confidence policy or null if below threshold
    if (policyRecommendations.length === 0) {
      return null;
    }

    const bestPolicy = policyRecommendations.reduce((best, current) =>
      current.confidence > best.confidence ? current : best
    );

    return bestPolicy.confidence >= (request.confidenceThreshold || this.confidenceThreshold)
      ? bestPolicy
      : null;
  }

  // Generate policy for specific regulatory framework
  private async generateFrameworkSpecificPolicy(
    roleProfile: RoleRegulatoryProfile,
    framework: RegulatoryFramework,
    requirement: any,
    request: PolicyGenerationRequest
  ): Promise<PolicyRecommendation | null> {

    // 1. Build regulatory context query
    const contextQuery = this.buildRegulatoryContextQuery(roleProfile, framework, requirement);

    // 2. Generate policy content using AI/LLM
    const policyContent = await this.generatePolicyContent(contextQuery, requirement, roleProfile);

    // 3. Validate and score the policy
    const validation = this.validatePolicy(policyContent, requirement, roleProfile);

    // 4. Create policy recommendation
    const recommendation: PolicyRecommendation = {
      roleTemplateId: roleProfile.roleTemplateId,
      roleTitle: roleProfile.roleTitle,
      regulatoryFramework: framework,
      policyTitle: `${framework} ${requirement.title} Policy`,
      policyContent,
      confidence: validation.confidence,
      regulatoryContext: this.extractRegulatoryContext(contextQuery),
      citations: [requirement.citation],
      autoGenerated: true,
      requiresReview: validation.requiresReview,
      createdAt: new Date()
    };

    return recommendation;
  }

  // Build regulatory context query for RAG
  private buildRegulatoryContextQuery(
    roleProfile: RoleRegulatoryProfile,
    framework: RegulatoryFramework,
    requirement: any
  ): string {
    const roleContext = `${roleProfile.roleTitle} (${roleProfile.category})`;
    const frameworkContext = `${framework} compliance requirements`;
    const specificContext = requirement.title;

    return `${roleContext} ${frameworkContext} ${specificContext} ${requirement.description}`;
  }

  // Generate policy content using AI/LLM (placeholder for now)
  private async generatePolicyContent(
    contextQuery: string,
    requirement: any,
    roleProfile: RoleRegulatoryProfile
  ): Promise<string> {
    // This would integrate with your existing LLM client
    // For now, return a structured template

    const policyTemplate = `
# ${requirement.title} Policy

## Purpose
This policy establishes requirements for ${roleProfile.roleTitle} (${roleProfile.category}) roles to ensure compliance with ${requirement.citation}.

## Scope
Applies to all ${roleProfile.roleTitle} personnel and related systems.

## Requirements
${requirement.specificPolicies.map((policy: string) => `- ${policy}`).join('\n')}

## Responsibilities
- ${roleProfile.roleTitle} personnel must implement all specified security controls
- Regular compliance monitoring and reporting required
- Annual policy review and updates mandatory

## Compliance
Non-compliance may result in disciplinary action and potential regulatory penalties.
    `.trim();

    return policyTemplate;
  }

  // Validate generated policy
  private validatePolicy(
    policyContent: string,
    requirement: { specificPolicies: string[]; impact: string },
    roleProfile: RoleRegulatoryProfile
  ): PolicyValidationResult {

    // 1. Content validation
    const hasRequiredElements = this.validatePolicyContent(policyContent, requirement);

    // 2. Regulatory coverage calculation
    const regulatoryCoverage = this.calculateRegulatoryCoverage(policyContent, requirement);

    // 3. Role specificity calculation
    const roleSpecificity = this.calculateRoleSpecificity(policyContent, roleProfile);

    // 4. Overall confidence calculation
    const confidence = (regulatoryCoverage + roleSpecificity) / 2;

    // 5. Compliance score
    const complianceScore = confidence * (requirement.impact === 'HIGH' ? 1.0 :
      requirement.impact === 'MEDIUM' ? 0.7 : 0.4);

    // 6. Determine if review is required
    const requiresReview = confidence < this.confidenceThreshold || complianceScore < 0.7;

    // 7. Generate recommendations
    const recommendations = this.generateValidationRecommendations(
      confidence, regulatoryCoverage, roleSpecificity, complianceScore
    );

    return {
      isValid: hasRequiredElements && confidence >= 0.7,
      confidence,
      regulatoryCoverage,
      roleSpecificity,
      complianceScore,
      recommendations,
      requiresReview
    };
  }

  // Validate policy content structure
  private validatePolicyContent(policyContent: string, requirement: any): boolean {
    const requiredSections = ['Purpose', 'Scope', 'Requirements', 'Responsibilities'];
    const content = policyContent.toLowerCase();

    return requiredSections.every(section =>
      content.includes(section.toLowerCase())
    ) && requirement.specificPolicies.every((policy: string) =>
      content.includes(policy.toLowerCase())
    );
  }

  // Calculate regulatory coverage score
  private calculateRegulatoryCoverage(policyContent: string, requirement: { specificPolicies: string[] }): number {
    const content = policyContent.toLowerCase();
    const requiredPolicies = requirement.specificPolicies.map((p: string) => p.toLowerCase());

    const coveredPolicies = requiredPolicies.filter(policy =>
      content.includes(policy)
    );

    return coveredPolicies.length / requiredPolicies.length;
  }

  // Calculate role specificity score
  private calculateRoleSpecificity(policyContent: string, roleProfile: RoleRegulatoryProfile): number {
    const content = policyContent.toLowerCase();
    const roleElements = [
      roleProfile.roleTitle.toLowerCase(),
      roleProfile.category.toLowerCase(),
      'personnel',
      'roles',
      'responsibilities'
    ];

    const presentElements = roleElements.filter(element =>
      content.includes(element)
    );

    return presentElements.length / roleElements.length;
  }

  // Generate validation recommendations
  private generateValidationRecommendations(
    confidence: number,
    regulatoryCoverage: number,
    roleSpecificity: number,
    complianceScore: number
  ): string[] {
    const recommendations: string[] = [];

    if (confidence < 0.8) {
      recommendations.push('Policy confidence below threshold - consider manual review');
    }

    if (regulatoryCoverage < 0.9) {
      recommendations.push('Some regulatory requirements not fully covered');
    }

    if (roleSpecificity < 0.8) {
      recommendations.push('Policy could be more role-specific');
    }

    if (complianceScore < 0.7) {
      recommendations.push('Compliance score indicates potential gaps');
    }

    if (recommendations.length === 0) {
      recommendations.push('Policy meets all quality thresholds');
    }

    return recommendations;
  }

  // Determine target regulatory frameworks
  private determineTargetFrameworks(
    roleProfile: RoleRegulatoryProfile,
    specificFramework?: RegulatoryFramework
  ): RegulatoryFramework[] {
    if (specificFramework) {
      return [specificFramework];
    }

    // Focus on high-impact frameworks by default
    return Object.entries(roleProfile.regulatoryImpact)
      .filter(([_, requirement]) => requirement.impact === 'HIGH')
      .map(([framework, _]) => framework as RegulatoryFramework);
  }

  // Extract regulatory context for citations
  private extractRegulatoryContext(contextQuery: string): string[] {
    // This would integrate with your RAG system to get actual regulatory context
    // For now, return the query as context
    return [contextQuery];
  }

  // Batch policy generation for multiple roles
  async generateBatchPolicyRecommendations(
    roleTemplateIds: string[],
    framework?: RegulatoryFramework
  ): Promise<PolicyRecommendation[]> {
    const recommendations: PolicyRecommendation[] = [];

    for (const roleId of roleTemplateIds) {
      try {
        const recommendation = await this.generatePolicyRecommendation({
          roleTemplateId: roleId,
          regulatoryFramework: framework
        });

        if (recommendation) {
          recommendations.push(recommendation);
        }
      } catch (error) {
        console.error(`Failed to generate policy for role ${roleId}:`, error);
      }
    }

    return recommendations.sort((a, b) => b.confidence - a.confidence);
  }

  // Get policy statistics
  getPolicyStatistics(): {
    totalRoles: number;
    highConfidencePolicies: number;
    mediumConfidencePolicies: number;
    lowConfidencePolicies: number;
    averageConfidence: number;
  } {
    const allProfiles = this.roleMatrix.getAllRoleProfiles();
    const totalRoles = allProfiles.length;

    let highConfidence = 0;
    let mediumConfidence = 0;
    let lowConfidence = 0;
    let totalConfidence = 0;

    allProfiles.forEach(profile => {
      const score = profile.complianceScore;
      if (score >= 0.8) highConfidence++;
      else if (score >= 0.6) mediumConfidence++;
      else lowConfidence++;

      totalConfidence += score;
    });

    return {
      totalRoles,
      highConfidencePolicies: highConfidence,
      mediumConfidencePolicies: mediumConfidence,
      lowConfidencePolicies: lowConfidence,
      averageConfidence: totalRoles > 0 ? totalConfidence / totalRoles : 0
    };
  }
}
