generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//
// ENUMS
//
enum BlockchainTxStatus {
  pending
  confirmed
  failed
}

enum BlockchainTxType {
  NFT_MINT
  TRANSFER
  OTHER
  APPROVAL_DECISION
}

enum RoleAgentStatus {
  active
  inactive
  suspended
  retired
}

enum ArtifactType {
  RoleAgent
  MCP
  ANS
  Signal
  Delegation
}

enum ApprovalFacet {
  security
  compliance
  policy
  risk
  legal
  privacy
  architecture
}

enum ApprovalDecision {
  approve
  reject
  pending
  abstain
}

enum PolicyStatus {
  draft
  active
  archived
}

enum LoALevel {
  L1
  L2
  L3
  L4
  L5
}

//
// MODELS
//
model AuditLog {
  id            String   @id @default(cuid())
  action        String
  entity        String
  entityId      String
  userId        String?
  organizationId String?
  roleAgentId   String?
  metadata      Json?
  createdAt     DateTime @default(now())

  organization Organization? @relation(fields: [organizationId], references: [id])
  roleAgent    RoleAgent?   @relation(fields: [roleAgentId], references: [id])

  @@index([action], map: "idx_audit_action")
  @@index([createdAt], map: "idx_audit_created")
  @@index([entity], map: "idx_audit_entity")
}

model BlockchainTransaction {
  id              String            @id @default(cuid())
  transactionHash String            @unique
  network         String
  blockNumber     Int?
  gasUsed         String?
  gasPrice        String?
  status          BlockchainTxStatus @default(pending)
  roleAgentId     String?
  transactionType BlockchainTxType?
  tokenId         String?
  contractAddress String?
  metadata        Json?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  roleAgent       RoleAgent?        @relation(fields: [roleAgentId], references: [id])
  approvalRequest ApprovalRequest?  @relation(fields: [approvalRequestId], references: [id])
  approvalRequestId String?

  @@index([transactionHash], map: "idx_blockchain_tx_hash")
  @@index([network], map: "idx_blockchain_tx_network")
  @@index([status], map: "idx_blockchain_tx_status")
  @@index([transactionType], map: "idx_blockchain_tx_type")
  @@index([tokenId], map: "idx_blockchain_tx_token")
}

model Certification {
  id            String      @id @default(cuid())
  name          String
  issuer        String
  issuedAt      DateTime
  expiresAt     DateTime?
  credentialUrl String?
  verified      Boolean     @default(false)
  verificationMethod String? // e.g. "manual", "onchain", "issuer_api"
  roleAgentId   String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  roleAgent     RoleAgent   @relation(fields: [roleAgentId], references: [id])

  @@index([roleAgentId], map: "idx_certifications_role_agent")
  @@index([expiresAt], map: "idx_certifications_expires")
  @@index([verified], map: "idx_certifications_verified")
}

model RoleAgent {
  id                      String                    @id @default(cuid())
  name                    String
  description             String?
  blockchainAddress       String?
  soulboundTokenId        String?
  blockchainNetwork       String?
  status                  RoleAgentStatus           @default(active)
  level                   Int                       @default(1)
  loaLevel                LoALevel?                // new: LoA level for this agent
  approvalStatus          ApprovalDecision          @default(pending) // approval status
  organizationId          String
  roleTemplateId          String
  assignedToDid           String?
  assignedToUserId        String?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  isEligibleForMint       Boolean                   @default(false)
  lastTrustCheck          DateTime?
  trustScore              Float?
  ansIdentifier           String?
  ansRegistrationStatus   String?                   @default("not_registered")
  ansRegistrationError    String?
  ansVerificationUrl      String?

  blockchainTransactions BlockchainTransaction[]
  certifications         Certification[]
  trustHistories         TrustHistory[]
  organization           Organization              @relation(fields: [organizationId], references: [id])
  roleTemplate           RoleTemplate              @relation(fields: [roleTemplateId], references: [id])
  signals                Signal[]
  auditLogs              AuditLog[]
  approvals              Approval[]                // new: approval tasks for this agent

  @@index([assignedToDid], map: "idx_role_agents_assigned_did")
  @@index([assignedToUserId], map: "idx_role_agents_assigned_user")
  @@index([blockchainAddress], map: "idx_role_agents_blockchain")
  @@index([isEligibleForMint], map: "idx_role_agents_eligible")
  @@index([organizationId], map: "idx_role_agents_org")
  @@index([roleTemplateId], map: "idx_role_agents_role")
  @@index([status], map: "idx_role_agents_status")
  @@index([trustScore], map: "idx_role_agents_trust")
  @@index([ansIdentifier], map: "idx_role_agents_ans")
  @@index([ansRegistrationStatus], map: "idx_role_agents_ans_status")
  @@index([loaLevel], map: "idx_role_agents_loa_level")
  @@index([approvalStatus], map: "idx_role_agents_approval_status")
}

model TrustHistory {
  id          String     @id @default(cuid())
  roleAgentId String
  trustScore  Float
  computedAt  DateTime   @default(now())
  metadata    Json?
  roleAgent   RoleAgent  @relation(fields: [roleAgentId], references: [id])

  @@index([roleAgentId], map: "idx_trust_histories_role_agent")
  @@index([computedAt], map: "idx_trust_histories_time")
}

model OrganizationMember {
  id             String        @id @default(cuid())
  organizationId String
  name           String
  email          String
  role           String
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  organization   Organization  @relation(fields: [organizationId], references: [id])
}

model Organization {
  id                    String                  @id @default(cuid())
  name                  String
  description           String?
  domain                String                  @unique
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  isActive              Boolean                 @default(true)
  onboardingComplete    Boolean                 @default(false)
  complianceTags        Json?

  roleAgents            RoleAgent[]
  organizationMembers   OrganizationMember[]
  roleTemplates         RoleTemplate[]
  roleTrustThresholds   RoleTrustThreshold[]
  loaPolicies           LoaPolicy[]
  approvals             Approval[]
  mcpPolicies           McpPolicy[]
  auditLogs             AuditLog[]
  approvalRequests      ApprovalRequest[]

  @@index([isActive], map: "idx_organizations_active")
  @@index([domain], map: "idx_organizations_domain")
}

model RoleTemplate {
  id                    String          @id @default(cuid())
  title                 String
  focus                 String
  category              String
  selectable            Boolean         @default(true)
  responsibilities      Json
  securityContributions Json
  organizationId        String?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  roleAgents            RoleAgent[]
  organization          Organization?   @relation(fields: [organizationId], references: [id])
}

model RoleTrustThreshold {
  id             String        @id @default(cuid())
  roleTitle      String
  minTrustScore  Float
  minLoALevel    Int?
  isActive       Boolean       @default(true)
  organizationId String
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  organization   Organization  @relation(fields: [organizationId], references: [id])

  @@unique([organizationId, roleTitle])
  @@index([organizationId], map: "idx_role_threshold_org")
}

model Signal {
  id            String        @id @default(cuid())
  type          String
  title         String
  description   String?
  metadata      Json?
  value         Float?
  confidence    Float?
  source        String
  sourceType    String?
  verified      Boolean       @default(false)
  roleAgentId   String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  url           String?
  roleAgent     RoleAgent     @relation(fields: [roleAgentId], references: [id])

  @@index([roleAgentId], map: "idx_signals_role_agent")
  @@index([type], map: "idx_signals_type")
  @@index([verified], map: "idx_signals_verified")
}

model LoaPolicy {
  id              String      @id @default(cuid())
  organizationId  String
  artifactType    ArtifactType
  level           LoALevel    // new: define LoA level
  minReviewers    Int
  requiredFacets  ApprovalFacet[]
  externalRequired Boolean    @default(false) // new: require external org?
  description     String?     // new: policy description
  isActive        Boolean     @default(true)  // new: enable/disable policy
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  organization    Organization @relation(fields: [organizationId], references: [id])

  @@index([organizationId], map: "idx_loa_policies_org")
  @@index([level], map: "idx_loa_policies_level")
  @@index([artifactType], map: "idx_loa_policies_artifact_type")
  @@unique([organizationId, artifactType, level]) // ensure unique policies per org/type/level
}

model Approval {
  id             String    @id @default(cuid())
  organizationId String
  artifactId     String
  artifactType   ArtifactType
  loaLevel       LoALevel  // new: which LoA policy applied
  reviewerId     String
  facet          ApprovalFacet
  decision       ApprovalDecision
  comment        String?
  reviewedAt     DateTime? // new: when decision was made
  createdAt      DateTime  @default(now())
  organization   Organization @relation(fields: [organizationId], references: [id])
  
  // Reverse relations for artifacts
  roleAgent      RoleAgent? @relation(fields: [artifactId], references: [id], map: "Approval_roleAgent_fkey")
  mcpPolicy      McpPolicy? @relation(fields: [artifactId], references: [id], map: "Approval_mcpPolicy_fkey")

  @@index([organizationId], map: "idx_approvals_org")
  @@index([loaLevel], map: "idx_approvals_loa_level")
  @@index([artifactType], map: "idx_approvals_artifact_type")
  @@unique([artifactId, artifactType, reviewerId, facet]) // ensures no duplicate reviews
}

model McpPolicy {
  id              String        @id @default(cuid())
  organizationId  String
  name            String
  version         Int           @default(1)
  status          PolicyStatus
  loaLevel        LoALevel?    // new: LoA level for this policy
  approvalStatus  ApprovalDecision @default(pending) // approval status
  regoModule      String
  sha256          String
  isDefault       Boolean       @default(false)
  scope           Json
  createdBy       String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  organization    Organization  @relation(fields: [organizationId], references: [id])
  mcpPolicyTests  McpPolicyTest[]
  approvals       Approval[]    // new: approval tasks for this policy

  @@index([organizationId], map: "idx_mcp_policies_org")
  @@index([status], map: "idx_mcp_policies_status")
  @@index([loaLevel], map: "idx_mcp_policies_loa_level")
  @@index([approvalStatus], map: "idx_mcp_policies_approval_status")
  @@unique([organizationId, name, version])
}

model McpPolicyTest {
  id         String        @id @default(cuid())
  policyId   String
  name       String
  input      Json
  expected   Json
  createdAt  DateTime      @default(now())
  mcpPolicy  McpPolicy     @relation(fields: [policyId], references: [id])

  @@index([policyId], map: "idx_mcp_policy_tests")
}

/// --- Milestone 1: AI & RAG tables ---

model knowledge_documents {
  id             String   @id @default(cuid())
  organizationId String?  // optional: null => global doc
  sourceType     String   // "manual" | "url" | "upload"
  sourceRef      String?  // URL, filename, or note
  title          String
  jurisdiction   String?  // "EU" | "US" | ...
  framework      String?  // "ISO27001" | "SOC2" | "EU AI Act" | ...
  version        String?  // "2022", "1.1", etc.
  language       String?  // "en", ...
  chunkIndex     Int      // we store as chunks
  content        String
  embedding      Bytes?   // swap to Vector via pgvector if preferred (see note)
  hash           String   // sha256(content)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([organizationId])
  @@index([framework])
  @@index([jurisdiction])
  @@index([hash], map: "idx_knowledge_hash")
}

model ai_recommendations {
  id              String   @id @default(cuid())
  organizationId  String?
  agentType       String   // "PolicyIntelligence" | "ComplianceIntelligence" | ...
  inputRef        String   // e.g. artifact composite key or payload hash
  outputJson      Json     // full recommendation object (policy draft, reasons, scores)
  confidence      Float?
  rationale       String?  // human-readable explanation
  citations       String[] // knowledge_document ids or URLs
  createdAt       DateTime @default(now())
}

model trust_ledger {
  id           String   @id @default(cuid())
  prevHash     String?
  eventType    String   // "AI_RECOMMENDATION" | "POLICY_DRAFTED" | "APPROVAL_REQUESTED" | ...
  payloadHash  String   // sha256 of canonical payload
  payload      Json     // canonical payload (small; avoid secrets)
  merkleRoot   String?  // optional batch anchoring
  anchoredTx   String?  // optional on-chain anchor tx
  createdAt    DateTime @default(now())

  @@index([eventType])
  @@index([createdAt])
}

model policy_bundles {
  id             String   @id @default(cuid())
  organizationId String?
  name           String
  version        Int      @default(1)
  status         String   // "draft" | "active" | "archived"
  regoModule     String   // Rego
  sha256         String
  signatures     Json?    // [{by, algo, sig}]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([status])
  @@index([organizationId])
}

model artifact_risk_profiles {
  id             String   @id @default(cuid())
  artifactType   String   // "MCP" | "RoleAgent" | "ANS"
  artifactId     String
  organizationId String?
  riskScore      Float
  rationale      String?
  lastReviewedAt DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([artifactType, artifactId])
  @@index([organizationId])
}

/// --- Governance Console: Unified LoA Approvals ---

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

/// --- Enhanced Facet-Aware Approval System (Phase 2) ---

// Extend existing ApprovalFacet enum with additional facets
// Note: ApprovalFacet enum already exists above, adding missing facets here

// Enhanced ApprovalRequest with facet awareness
model ApprovalRequest {
  id                 String         @id @default(cuid())
  organizationId     String?
  artifactId         String         // ID of the artifact being approved
  artifactType       String         // "MCP_POLICY" | "ROLE_AGENT" | "ANS_ENTRY" | "AI_RECOMMENDATION"
  loaLevel           Int            // LoA level required (1-5)
  status             ApprovalStatus @default(PENDING)
  requestorId        String?        // Who requested the approval
  requestorType      String?        // "USER" | "SYSTEM" | "AI_AGENT"
  requestReason      String?        // Why approval is needed
  priority           String?        // "LOW" | "MEDIUM" | "HIGH" | "CRITICAL"
  dueDate            DateTime?      // When approval is needed by
  reviewers          Json           // List of assigned reviewers with roles
  reviewHistory      Json?          // History of review decisions and comments
  metadata           Json?          // Additional artifact-specific data
  
  // Enhanced facet-aware fields
  requiredFacets     ApprovalFacet[] // materialized from LoA policy at creation
  approvalsSatisfied Boolean        @default(false)
  rejectionCount     Int            @default(0)
  
  // Explainability attachment
  explainId          String?
  explain            Explainability? @relation(fields: [explainId], references: [id])
  
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  // Relations
  organization       Organization?  @relation(fields: [organizationId], references: [id])
  blockchainTransactions BlockchainTransaction[]
  decisions          ApprovalDecision[]
  votes              ApprovalVote[]

  @@index([organizationId])
  @@index([artifactType])
  @@index([status])
  @@index([loaLevel])
  @@index([dueDate])
  @@index([createdAt])
}

// Individual facet votes
model ApprovalVote {
  id                 String         @id @default(cuid())
  approvalRequestId  String
  facet              ApprovalFacet
  reviewerId         String
  vote               ApprovalDecision
  comment            String?
  signature          Bytes?         // Optional PKI/wallet signature
  publicKeyRef       String?        // Reference to signing key
  createdAt          DateTime       @default(now())
  
  // Relations
  approvalRequest    ApprovalRequest @relation(fields: [approvalRequestId], references: [id])
  
  @@unique([approvalRequestId, facet, reviewerId]) // one vote per facet per reviewer
  @@index([approvalRequestId])
  @@index([facet])
  @@index([reviewerId])
  @@index([createdAt])
}

// Note: ApprovalDecision model already exists above for backward compatibility

// Explainability data model
model Explainability {
  id              String   @id @default(cuid())
  summary         String   // human-readable rationale
  riskScore       Float?
  riskFactors     Json?    // [{label, score, detail}]
  citations       Json?    // [{docId, title, chunkId, score}]
  aiReasoning     Json?    // structured LLM trace (no PII)
  modelRef        String?  // provider/model/version
  redactionSummary String? // what was redacted before AI processing
  createdAt       DateTime @default(now())
  
  // Relations
  approvalRequests ApprovalRequest[]
  
  @@index([createdAt])
}

// Enhanced Trust Ledger with threading
model TrustLedgerEvent {
  id           String       @id @default(cuid())
  artifactType String       // "MCP_POLICY" | "ROLE_AGENT" | "ANS_ENTRY" | "AI_RECOMMENDATION"
  artifactId   String
  action       String       // "APPROVAL_VOTE" | "APPROVAL_FINAL" | "POLICY_PUBLISH" | ...
  payload      Json
  contentHash  String       // sha256(payload canonicalized)
  prevHash     String?
  chainHash    String?      // set to batch.merkleRoot when anchored
  batchId      String?
  createdAt    DateTime     @default(now())
  
  @@index([artifactType, artifactId, createdAt])
  @@index([batchId])
}

// Batch anchoring for blockchain
model TrustLedgerBatch {
  id          String   @id @default(cuid())
  fromEventId String
  toEventId   String
  merkleRoot  String
  anchoredTx  String?  // link to blockchain_transactions
  createdAt   DateTime @default(now())
  
  @@index([merkleRoot])
  @@index([createdAt])
}

// Enhanced Knowledge System for Vector Migration
model KnowledgeDocument {
  id         String   @id @default(cuid())
  orgId      String?
  title      String
  source     String   // 'REGULATORY'|'POLICY'|'DOC'|'URL'
  url        String?
  hash       String   @unique
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  // Relations
  chunks     KnowledgeChunk[]
  
  @@index([orgId])
  @@index([source])
  @@index([hash])
}

model KnowledgeChunk {
  id            String   @id @default(cuid())
  documentId    String
  ordinal       Int
  text          String
  tokens        Int
  embeddingV    Unsupported("vector") // @db.Vector(768) when Prisma supports it
  embeddingJson Json?    // fallback for migration safety
  embeddingModel String? // model identifier
  embeddingVersion String? // model version
  createdAt     DateTime @default(now())
  
  // Relations
  document      KnowledgeDocument @relation(fields: [documentId], references: [id])
  
  @@index([documentId, ordinal])
  @@index([embeddingModel])
}
